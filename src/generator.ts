export namespace Generators {

    const upperCamelCase = require('uppercamelcase');

    class GeneratorError extends Error {
    }

    interface StatementList {
        type: String;
        statements: Statement[];
    }

    interface Statement {
        type: String;
    }

    interface NamespaceStatement extends Statement {
        namespace: String;
    }

    interface TypeStatement extends Statement {
        name: String
        fields: FieldStatement[];
    }

    interface FieldStatement extends Statement {
        name: String;
        fieldType: FieldTypeStatement;
    }

    interface FieldTypeStatement extends Statement {
        name: String;
        isScalar: boolean;
        isArray: boolean;
    }

    export abstract class Generator {
        static STATEMENT_LIST = "statement_list";
        static NAMESPACE_DECL = "namespace_decl";
        static STRUCT_DECL = "struct_decl";
        static TABLE_DECL = "table_decl";

        protected namespace: String;
        protected types: TypeStatement[];

        constructor(schema: StatementList) {
            if (schema.type != Generator.STATEMENT_LIST)
                throw new GeneratorError(`Missing '${Generator.STATEMENT_LIST}'`);

            if (schema.statements.length == 0)
                throw new GeneratorError(`Missing statements in '${Generator.STATEMENT_LIST}'`);

            this.findNamespace(schema);
            this.findTypes(schema);
        }

        private findNamespace(schema: StatementList) {
            for (let statement of schema.statements) {
                if (statement.type == Generator.NAMESPACE_DECL) {
                    let nss = <NamespaceStatement>statement;
                    if (this.namespace == null) {
                        this.namespace = nss.namespace;
                        console.info(`Found namespace ${nss.namespace}`);
                    }
                    else
                        throw new GeneratorError(`Duplicate namespace`);
                }
            }
        }

        private findTypes(schema: StatementList) {
            this.types = [];

            for (let statement of schema.statements) {
                if (statement.type == Generator.STRUCT_DECL || statement.type == Generator.TABLE_DECL) {
                    this.types.push(<TypeStatement>statement);
                }
            }
        }

        protected isType(typeName: String): boolean {
            return this.types.findIndex(t => t.name == typeName) >= 0;
        }

        public abstract generate(): String;

        public abstract ext(): String;
    }

    export class CSharpGenerator extends Generator {
        constructor(schema) {
            super(schema)
        }

        public generate(): String {
            let code = `// automatically generated by fbagen, do not modify
`;

            code += this.beginNamespace();

            for (let type of this.types) {
                code += this.addType(type);
            }

            code += this.endNamespace();

            return code;
        }

        beginNamespace(): String {
            return `
namespace ${this.namespace}
{
`
        }

        endNamespace(): String {
            return `
}`
        }

        addType(type: TypeStatement): String {
            console.log(JSON.stringify(type));

            let isStruct = type.type == Generator.STRUCT_DECL;
            let code = ``;

            code += this.beginType(type.name, isStruct, true);

            for (let field of type.fields) {
                code += this.addTypeField(field, isStruct, true);
            }

            code += this.endType();

            return code;
        }

        beginType(typeName: String, isStruct: boolean, isMutable: boolean): String {
            return `
    public ${isStruct ? 'struct' : 'class'} ${isMutable ? 'Mutable' : 'Immutable'}${typeName}
    {
`;
        }

        endType(): String {
            return `
    }
`;
        }

        addTypeField(field: FieldStatement, isStruct: boolean, isMutable: boolean): String {
            let fieldType = <FieldTypeStatement>field.fieldType;
            let fieldTypeName = fieldType.name;
            if (fieldType.isScalar) {
                // C# conversion: ubyte -> byte, byte -> sbyte
                if (fieldTypeName == "ubyte")
                    fieldTypeName = "byte";
                else if (fieldTypeName == "byte")
                    fieldTypeName = "sbyte";
            } else if (this.isType(fieldType.name)) {
                fieldTypeName = `${isMutable ? 'Mutable' : 'Immutable'}${fieldType.name}`;
            }
            else {
                console.warn(`Not implemented yet ${JSON.stringify(fieldTypeName)}`);
            }

            if (fieldType.isArray)
                fieldTypeName += '[]';

            let code = `
        public ${fieldTypeName} ${upperCamelCase(field.name)}`;
            if (isStruct)
                code += `;
`;
            else
                code += ` { get; set; }
`;

            return code;
        }

        public ext(): String {
            return ".cs";
        }
    }
}
