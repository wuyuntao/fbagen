// automatically generated by fbagen, do not modify
using FlatBuffers;
using FlatBuffers.Schema;
using System;

namespace MyGame.Schema
{

    public struct MutableVec3
    {

        public float X;

        public float Y;

        public float Z;

    }

    public class Vec3Serializer : Serializer<MutableVec3, Vec3>
    {
        public static readonly Vec3Serializer Instance = SerializerSet.Instance.CreateSerializer<Vec3Serializer, MutableVec3, Vec3>();

        public override Offset<Vec3> Serialize(FlatBufferBuilder fbb, MutableVec3 obj)
        {
            return Vec3.CreateVec3(fbb, obj.X, obj.Y, obj.Z);
        }

        protected override Vec3 GetRootAs(ByteBuffer buffer)
        {
            throw new NotImplementedException();
        }

        public override MutableVec3 Deserialize(Vec3 obj)
        {
            var accessor = new MutableVec3();
            accessor.X = obj.X;
            accessor.Y = obj.Y;
            accessor.Z = obj.Z;
            return accessor;
        }

    }

    public class MutableMonster
    {

        public uint Id { get; set; }

        public MutableVec3 Pos { get; set; }

        public short Mana { get; set; }

        public short Hp { get; set; }

        public string Name { get; set; }

        public byte[] Inventory { get; set; }

        public Color Color { get; set; }

        // Any test is not implemented yet

    }

    public class MonsterSerializer : Serializer<MutableMonster, Monster>
    {
        public static readonly MonsterSerializer Instance = SerializerSet.Instance.CreateSerializer<MonsterSerializer, MutableMonster, Monster>();

        public override Offset<Monster> Serialize(FlatBufferBuilder fbb, MutableMonster obj)
        {
            Monster.StartMonster(fbb);
            Monster.AddId(fbb, obj.Id);
            Monster.AddPos(fbb, Vec3Serializer.Instance.Serialize(fbb, obj.Pos));
            Monster.AddMana(fbb, obj.Mana);
            Monster.AddHp(fbb, obj.Hp);
            if (!string.IsNullOrEmpty(obj.Name))
                 Monster.AddName(fbb, fbb.CreateString(obj.Name));
            Monster.AddInventory(fbb, Monster.CreateInventoryVector(fbb, obj.Inventory));
            Monster.AddColor(fbb, obj.Color);
            // Any Test is not implemented yet
            return Monster.EndMonster(fbb);

        }

        protected override Monster GetRootAs(ByteBuffer buffer)
        {
            return Monster.GetRootAsMonster(buffer);
        }

        public override MutableMonster Deserialize(Monster obj)
        {
            var accessor = new MutableMonster();
            accessor.Id = obj.Id;
            accessor.Pos = Vec3Serializer.Instance.Deserialize(obj.Pos);
            accessor.Mana = obj.Mana;
            accessor.Hp = obj.Hp;
            accessor.Name = obj.Name;
            accessor.Inventory = DeserializeScalar(obj.InventoryLength, obj.Inventory);
            accessor.Color = obj.Color;
            // Any Test is not implemented yet
            return accessor;
        }

    }

    public class MutableWeapon
    {

        public uint Id { get; set; }

        public string[] Tags { get; set; }

    }

    public class WeaponSerializer : Serializer<MutableWeapon, Weapon>
    {
        public static readonly WeaponSerializer Instance = SerializerSet.Instance.CreateSerializer<WeaponSerializer, MutableWeapon, Weapon>();

        public override Offset<Weapon> Serialize(FlatBufferBuilder fbb, MutableWeapon obj)
        {
            Weapon.StartWeapon(fbb);
            Weapon.AddId(fbb, obj.Id);
            Weapon.AddTags(fbb, Weapon.CreateTagsVector(fbb, SerializeString(fbb, obj.Tags)));
            return Weapon.EndWeapon(fbb);

        }

        protected override Weapon GetRootAs(ByteBuffer buffer)
        {
            return Weapon.GetRootAsWeapon(buffer);
        }

        public override MutableWeapon Deserialize(Weapon obj)
        {
            var accessor = new MutableWeapon();
            accessor.Id = obj.Id;
            accessor.Tags = DeserializeScalar(obj.TagsLength, obj.Tags);
            return accessor;
        }

    }

    public class MutablePickup
    {

        public uint Id { get; set; }

    }

    public class PickupSerializer : Serializer<MutablePickup, Pickup>
    {
        public static readonly PickupSerializer Instance = SerializerSet.Instance.CreateSerializer<PickupSerializer, MutablePickup, Pickup>();

        public override Offset<Pickup> Serialize(FlatBufferBuilder fbb, MutablePickup obj)
        {
            Pickup.StartPickup(fbb);
            Pickup.AddId(fbb, obj.Id);
            return Pickup.EndPickup(fbb);

        }

        protected override Pickup GetRootAs(ByteBuffer buffer)
        {
            return Pickup.GetRootAsPickup(buffer);
        }

        public override MutablePickup Deserialize(Pickup obj)
        {
            var accessor = new MutablePickup();
            accessor.Id = obj.Id;
            return accessor;
        }

    }

    public class MutableScene
    {

        public MutableMonster[] Monsters { get; set; }

    }

    public class SceneSerializer : Serializer<MutableScene, Scene>
    {
        public static readonly SceneSerializer Instance = SerializerSet.Instance.CreateSerializer<SceneSerializer, MutableScene, Scene>();

        public override Offset<Scene> Serialize(FlatBufferBuilder fbb, MutableScene obj)
        {
            Scene.StartScene(fbb);
            Scene.AddMonsters(fbb, Scene.CreateMonstersVector(fbb, MonsterSerializer.Instance.Serialize(fbb, obj.Monsters)));
            return Scene.EndScene(fbb);

        }

        protected override Scene GetRootAs(ByteBuffer buffer)
        {
            return Scene.GetRootAsScene(buffer);
        }

        public override MutableScene Deserialize(Scene obj)
        {
            var accessor = new MutableScene();
            accessor.Monsters = MonsterSerializer.Instance.Deserialize(obj.MonstersLength, obj.Monsters);
            return accessor;
        }

    }

}